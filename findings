───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── lint ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
cmd [1] | flake8
./tests/conftest.py:288:65: B023 Function definition does not bind loop variable 'ps'.
./tests/opentelemetry/test_trace.py:22:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/opentelemetry/test_trace.py:53:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/opentelemetry/test_trace.py:72:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/opentelemetry/test_trace.py:100:13: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/opentelemetry/test_span.py:152:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/debugging/test_config.py:39:5: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/debugging/exploration/_profiler.py:65:13: B020 Found for loop that reassigns the iterable it is iterating with each iterable value.
./tests/internal/remoteconfig/test_remoteconfig_client_e2e.py:26:19: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./tests/internal/remoteconfig/test_remoteconfig_client_e2e.py:27:25: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./tests/contrib/langchain/test_langchain.py:237:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/aiomysql/test_aiomysql.py:56:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:82:121: E501 line too long (125 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:84:121: E501 line too long (133 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:85:121: E501 line too long (125 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:86:121: E501 line too long (141 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:87:121: E501 line too long (133 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:88:121: E501 line too long (125 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:89:121: E501 line too long (127 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:90:121: E501 line too long (131 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:91:121: E501 line too long (125 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:92:121: E501 line too long (125 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:94:121: E501 line too long (123 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:95:121: E501 line too long (123 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:97:121: E501 line too long (131 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:98:121: E501 line too long (149 > 120 characters)
./tests/contrib/pytest_benchmark/test_pytest_benchmark.py:99:121: E501 line too long (129 > 120 characters)
./tests/contrib/wsgi/test_wsgi.py:84:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/wsgi/test_wsgi.py:266:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/wsgi/test_wsgi.py:295:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/httplib/test_httplib.py:138:1: W293 blank line contains whitespace
./tests/contrib/httplib/test_httplib.py:614:13: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/tornado/utils.py:5:1: I001 isort found an import in the wrong position
./tests/contrib/tornado/utils.py:6:1: I001 isort found an import in the wrong position
./tests/contrib/tornado/web/app.py:306:23: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./tests/contrib/pylons/test_pylons.py:132:9: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/pylons/test_pylons.py:326:9: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/pylons/test_pylons.py:348:9: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/pylons/test_pylons.py:367:9: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/pylons/test_pylons.py:386:9: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/pylons/test_pylons.py:405:9: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/pylons/test_pylons.py:816:9: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/grpc_aio/test_grpc_aio.py:105:13: B011 Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().
./tests/contrib/sqlite3/test_sqlite3.py:86:13: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/urllib3/test_urllib3.py:390:13: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/aws_lambda/test_aws_lambda.py:38:17: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./tests/contrib/django/conftest.py:6:1: F811 redefinition of unused 'os' from line 1
./tests/contrib/django/conftest.py:6:1: I001 isort found an import in the wrong position
./tests/contrib/django/conftest.py:56:1: E302 expected 2 blank lines, found 1
./tests/contrib/django/conftest.py:60:1: E305 expected 2 blank lines after class or function definition, found 1
./tests/contrib/django/conftest.py:68:30: W292 no newline at end of file
./tests/contrib/django/test_django_appsec.py:39:13: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./tests/contrib/django/test_django_appsec_iast.py:28:13: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./tests/contrib/django/test_django_appsec_api_security.py:24:13: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./tests/contrib/vertica/test_vertica.py:293:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/vertica/test_vertica.py:295:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/vertica/test_vertica.py:298:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/vertica/test_vertica.py:576:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/vertica/test_vertica.py:578:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/vertica/test_vertica.py:581:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/vertica/test_vertica.py:622:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/vertica/test_vertica.py:624:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/vertica/test_vertica.py:627:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./tests/contrib/asyncio/test_tracer.py:79:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/asyncio/test_tracer.py:101:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/contrib/rq/test_rq.py:67:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/appsec/test_remoteconfiguration_e2e.py:272:5: B011 Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().
./tests/appsec/test_remoteconfiguration_e2e.py:292:5: B011 Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().
./tests/appsec/iast/iast_utils.py:13:5: B011 Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().
./tests/appsec/iast/fixtures/aspects/str_methods.py:793:44: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./tests/profiling/simple_program.py:16:5: B011 Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().
./tests/profiling/collector/test_stack.py:305:13: B011 Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().
./tests/profiling/collector/test_threading.py:350:9: B011 Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().
./tests/opentracer/test_tracer_asyncio.py:58:5: B017 `assertRaises(Exception)` and `pytest.raises(Exception)` should be considered evil. They can lead to your test passing even if the code being tested is never executed due to a typo. Assert for a more specific exception (builtin or custom), or use `assertRaisesRegex` (if using `assertRaises`), or add the `match` keyword argument (if using `pytest.raises`), or use the context manager form with a target.
./tests/vendor/test_contextvars.py:77:13: B015 Result of comparison is not used. This line doesn't do anything. Did you intend to prepend it with assert?
./benchmarks/bm/_scenario.py:83:13: B012 return/continue/break inside finally blocks cause exceptions to be silenced. Exceptions should be silenced in except blocks. Control statements can be moved outside the finally block.
./ddtrace/bootstrap/sitecustomize.py:63:9: B028 No explicit stacklevel keyword argument found. The warn method from the warnings module uses a stacklevel of 1 by default. This will only show a stack trace for the line on which the warn method is called. It is therefore recommended to use a stacklevel of 2 or greater to provide more information to the user.
./ddtrace/ext/ci.py:11:1: I001 isort found an import in the wrong position
./ddtrace/ext/ci.py:243:22: B005 Using .strip() with multi-character strings is misleading the reader. It looks like stripping a substring. Move your character set to a constant if this is deliberate. Use .replace(), .removeprefix(), .removesuffix(), or regular expressions to remove string fragments.
./ddtrace/internal/injection.py:49:14: F821 undefined name 'i'
./ddtrace/internal/injection.py:49:16: F821 undefined name 'i'
./ddtrace/internal/injection.py:58:14: F821 undefined name 'i'
./ddtrace/internal/injection.py:58:16: F821 undefined name 'i'
./ddtrace/internal/injection.py:69:14: F821 undefined name 'i'
./ddtrace/internal/injection.py:69:16: F821 undefined name 'i'
./ddtrace/internal/utils/http.py:349:9: B014 Redundant exception types in `except (OSError, IOError) as e:`.  Write `except OSError as e:`, which catches exactly the same exceptions.
./ddtrace/internal/datadog/profiling/ddup.py:5:1: I001 isort found an import in the wrong position
./ddtrace/internal/datadog/profiling/ddup.py:6:1: I003 isort expected 1 blank line in imports, found 0
./ddtrace/internal/telemetry/writer.py:428:60: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./ddtrace/internal/ci_visibility/git_client.py:79:71: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./ddtrace/internal/ci_visibility/git_client.py:108:39: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
./ddtrace/contrib/asgi/utils.py:53:8: B004 Using `hasattr(x, '__call__')` to test if `x` is callable is unreliable. If `x` implements custom `__getattr__` or its `__call__` is itself not callable, you might get misleading results. Use `callable(x)` for consistent results.
./ddtrace/contrib/httplib/patch.py:14:1: I001 isort found an import in the wrong position
./ddtrace/contrib/psycopg/patch.py:193:89: B026 Star-arg unpacking after a keyword argument is strongly discouraged, because it only works when the keyword parameter is declared after all parameters supplied by the unpacked sequence, and this change of ordering can surprise and mislead readers.
./ddtrace/contrib/django/patch.py:535:25: B012 return/continue/break inside finally blocks cause exceptions to be silenced. Exceptions should be silenced in except blocks. Control statements can be moved outside the finally block.
./ddtrace/contrib/openai/patch.py:394:21: B012 return/continue/break inside finally blocks cause exceptions to be silenced. Exceptions should be silenced in except blocks. Control statements can be moved outside the finally block.
./ddtrace/contrib/openai/patch.py:420:21: B012 return/continue/break inside finally blocks cause exceptions to be silenced. Exceptions should be silenced in except blocks. Control statements can be moved outside the finally block.
./ddtrace/appsec/iast/_patch.py:77:56: B006 Do not use mutable data structures for argument defaults.  They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.
