import csv
import pathlib
import sys
from typing import Dict
from typing import List
from typing import Set
from typing import Tuple

from packaging.version import parse as parse_version


sys.path.append(str(pathlib.Path(__file__).parent.parent.resolve()))
import riotfile  # noqa:E402


OUT_FILENAME = "min_compatible_versions.csv"


def _format_version_specifiers(spec: Set[str]) -> Set[str]:
    return set([part for v in [v.split(",") for v in spec if v] for part in v if "!=" not in part])


def tree_pkgs_from_riot() -> Dict[str, Set[str]]:
    tree_pkgs = _tree_pkgs_from_riot(riotfile.venv)
    _merge_tree_pkgs(tree_pkgs, get_project_dependencies())
    return tree_pkgs


def _pkgs_with_relevant_compatibility(pkgs: Dict[str, List]) -> Dict[str, List]:
    return {pkg: versions for pkg, versions in pkgs.items() if "github.com" not in pkg}


def _node_has_relevant_compatibility(node: riotfile.Venv) -> bool:
    return node.command is None or "pytest" in node.command


def _split_pkg_and_spec(pkg_and_spec: str) -> Tuple[str, str]:
    earliest_separator_index = len(pkg_and_spec)
    for spec_char in ("<", "=", ">", "~"):
        if spec_char in pkg_and_spec:
            earliest_separator_index = min(earliest_separator_index, pkg_and_spec.index(spec_char))
    return pkg_and_spec[:earliest_separator_index], pkg_and_spec[earliest_separator_index:]


def get_project_dependencies() -> Dict[str, Set]:
    pyproject_path = (pathlib.Path(__file__).parent.parent / "pyproject.toml").resolve()
    with open(pyproject_path, "r") as f:
        pyproject_contents = f.readlines()
    in_deps = False
    project_dependencies = {}
    for line in pyproject_contents:
        if in_deps:
            if line.startswith("]"):
                in_deps = False
            else:
                pkg, spec = _split_pkg_and_spec(line.strip().split(";")[0].strip('",'))
                project_dependencies[pkg] = set([spec] if spec else [])
        if line.startswith("dependencies ="):
            in_deps = True
    return project_dependencies


def _merge_tree_pkgs(tree_pkgs: Dict[str, Set], to_add: Dict[str, Set]):
    for pkg_name, versions in to_add.items():
        if pkg_name in tree_pkgs:
            tree_pkgs[pkg_name] = tree_pkgs[pkg_name].union(versions)
        else:
            tree_pkgs[pkg_name] = versions


def _tree_pkgs_from_riot(node: riotfile.Venv) -> Dict[str, Set]:
    if not _node_has_relevant_compatibility(node):
        return {}
    result = {
        pkg: _format_version_specifiers(set(versions))
        for pkg, versions in _pkgs_with_relevant_compatibility(node.pkgs).items()
    }
    for child_venv in node.venvs:
        _merge_tree_pkgs(result, _tree_pkgs_from_riot(child_venv))
    return result


def min_version_spec(version_specs: List[str]) -> str:
    min_numeric = ""
    min_spec = ""
    for spec in version_specs:
        numeric = parse_version(spec.strip("~==<>"))
        if not min_numeric or numeric < min_numeric:
            min_numeric = numeric
            min_spec = spec
    return min_spec


def write_out(all_pkgs: Dict[str, Set[str]]) -> None:
    with open(OUT_FILENAME, "w") as csvfile:
        csv_writer = csv.writer(csvfile, delimiter=",")
        csv_writer.writerow(["This file was generated by scripts/min_compatible_versions.py"])
        csv_writer.writerow(["pkg_name", "min_version"])
        for pkg, versions in sorted(all_pkgs.items()):
            min_version = "0"
            if versions:
                min_version = str(min_version_spec(versions)).strip()
            print("%s\n\tTested versions: %s\n\tMinimum: %s" % (pkg, sorted(list(versions)), min_version))
            csv_writer.writerow([pkg, min_version])


def main():
    """Discover the minimum version of every package referenced in the riotfile

    Writes to stdout and min_versions.csv
    """
    write_out(tree_pkgs_from_riot())


main()
