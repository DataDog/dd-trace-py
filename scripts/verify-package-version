#!/usr/bin/env scripts/uv-run-script
# -*- mode: python -*-
# /// script
# requires-python = ">=3.9"
# dependencies = ["packaging"]
# ///
"""Verify and update static versions in pyproject.toml and ddtrace/version.py.

Performs the following validations:
- Ensures version in pyproject.toml is PEP 440 compliant (e.g., "4.1.0.dev0" not "4.1.0.dev")
- Verifies __version__ in ddtrace/version.py matches __version_tuple__ when parsed
- Checks that versions in both files are consistent

Usage:
    scripts/verify-package-version       # Check versions match (exit 0 if OK, 1 if mismatch)
    scripts/verify-package-version --fix # Update version.py from pyproject.toml
"""

from pathlib import Path
import re
import sys

from packaging.version import InvalidVersion
from packaging.version import Version


try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib  # type: ignore[import-not-found]


def is_pep440_compliant(version_str: str) -> tuple[bool, str]:
    """Check if a version string is strictly PEP 440 compliant.

    Returns:
        Tuple of (is_compliant, normalized_version)
    """
    try:
        parsed = Version(version_str)
        normalized = str(parsed)

        # Check if the original matches the normalized form
        # If they differ, the version had implicit defaults which is not strictly compliant
        is_compliant = version_str == normalized
        return is_compliant, normalized
    except InvalidVersion:
        return False, ""


def version_to_tuple(version_str: str) -> tuple:
    """Convert a PEP 440 version string to a 4-element tuple.

    Returns a tuple of (major, minor, micro, pre_release_identifier)
    where pre_release_identifier is a string like "rc1", "dev0", "post1", or "".

    Raises:
        InvalidVersion: If the version string is not PEP 440 compliant.
    """
    parsed = Version(version_str)
    major, minor, micro = parsed.release[:3]

    # Build the pre-release identifier
    pre_id_parts = []
    if parsed.pre:
        pre_id_parts.append(f"{parsed.pre[0]}{parsed.pre[1]}")
    if parsed.post is not None:
        pre_id_parts.append(f"post{parsed.post}")
    if parsed.dev is not None:
        pre_id_parts.append(f"dev{parsed.dev}")
    if parsed.local:
        pre_id_parts.append(f"+{parsed.local}")

    pre_id = "".join(pre_id_parts) if pre_id_parts else ""

    return (major, minor, micro, pre_id)


def read_pyproject_version(pyproject_path: Path) -> str:
    """Read version from pyproject.toml."""
    with open(pyproject_path, "rb") as f:
        data = tomllib.load(f)
    return data["project"]["version"]


def read_version_py(version_path: Path) -> tuple:
    """Read version and version_tuple from ddtrace/version.py.

    Returns:
        Tuple of (version_string, version_tuple)
    """
    content = version_path.read_text()

    version_match = re.search(r'__version__\s*=\s*version\s*=\s*"([^"]+)"', content)
    if not version_match:
        raise ValueError("Could not find __version__ in version.py")
    version = version_match.group(1)

    tuple_match = re.search(r"__version_tuple__\s*=\s*version_tuple\s*=\s*(\([^)]+\))", content)
    if not tuple_match:
        raise ValueError("Could not find __version_tuple__ in version.py")
    version_tuple = eval(tuple_match.group(1))

    return version, version_tuple


def format_tuple_with_double_quotes(tup: tuple) -> str:
    """Format a tuple using double quotes for strings instead of single quotes."""
    elements = []
    for item in tup:
        if isinstance(item, str):
            elements.append(f'"{item}"')
        else:
            elements.append(repr(item))
    return f"({', '.join(elements)})"


def update_version_py(version_path: Path, new_version: str, new_version_tuple: tuple) -> None:
    """Update version and version_tuple in ddtrace/version.py."""
    content = version_path.read_text()

    version_tuple_str = format_tuple_with_double_quotes(new_version_tuple)

    content = re.sub(
        r'__version__\s*=\s*version\s*=\s*"[^"]+"',
        f'__version__ = version = "{new_version}"',
        content,
    )

    content = re.sub(
        r"__version_tuple__\s*=\s*version_tuple\s*=\s*\([^)]+\)",
        f"__version_tuple__ = version_tuple = {version_tuple_str}",
        content,
    )

    version_path.write_text(content)


def main() -> int:
    """Main entry point."""
    fix = "--fix" in sys.argv

    repo_root = Path(__file__).parent.parent
    pyproject_path = repo_root / "pyproject.toml"
    version_path = repo_root / "ddtrace" / "version.py"

    try:
        pyproject_version = read_pyproject_version(pyproject_path)

        # Check PEP 440 compliance
        is_compliant, normalized_version = is_pep440_compliant(pyproject_version)
        if not is_compliant:
            print(f"✗ Version in pyproject.toml is not PEP 440 compliant: {pyproject_version}", file=sys.stderr)
            print(f"  PEP 440 requires explicit numbers for pre-release, post, and dev versions", file=sys.stderr)
            print(f"  Suggested fix: {normalized_version}", file=sys.stderr)
            return 1

        # Validate that the version is PEP 440 parseable
        try:
            pyproject_version_tuple = version_to_tuple(pyproject_version)
        except InvalidVersion as e:
            print(f"✗ Invalid version in pyproject.toml: {pyproject_version}", file=sys.stderr)
            print(f"  Error: {e}", file=sys.stderr)
            return 1

        current_version, current_version_tuple = read_version_py(version_path)

        # Verify that __version__ and __version_tuple__ in version.py are consistent
        try:
            derived_tuple = version_to_tuple(current_version)
            if derived_tuple != current_version_tuple:
                print(f"✗ Version mismatch in ddtrace/version.py:", file=sys.stderr)
                print(f"  __version__ '{current_version}' converts to tuple {derived_tuple}", file=sys.stderr)
                print(f"  __version_tuple__ is {current_version_tuple}", file=sys.stderr)
                print("\nRun with --fix to update ddtrace/version.py")
                return 1
        except InvalidVersion as e:
            print(f"✗ Invalid version in ddtrace/version.py: {current_version}", file=sys.stderr)
            print(f"  Error: {e}", file=sys.stderr)
            return 1

        if current_version == pyproject_version and current_version_tuple == pyproject_version_tuple:
            print("✓ Versions match!")
            return 0

        if not fix:
            print("✗ Version mismatch detected:")
            print(f"  pyproject.toml:      {pyproject_version} {pyproject_version_tuple}")
            print(f"  ddtrace/version.py:  {current_version} {current_version_tuple}")
            print("\nRun with --fix to update ddtrace/version.py")
            return 1

        update_version_py(version_path, pyproject_version, pyproject_version_tuple)
        print(f"✓ Updated ddtrace/version.py to {pyproject_version} {pyproject_version_tuple}")
        return 0

    except Exception as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
