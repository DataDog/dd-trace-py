from contextlib import contextmanager
from typing import Dict
from typing import Iterator
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Union

from opentelemetry import version
from opentelemetry.context import Context as OtelContext
from opentelemetry.trace import Link as OtelLink
from opentelemetry.trace import SpanKind as OtelSpanKind
from opentelemetry.trace import Tracer as OtelTracer
from opentelemetry.trace import TracerProvider as OtelTracerProvider
from opentelemetry.trace import use_span
from opentelemetry.trace.propagation import get_current_span
from opentelemetry.trace.span import INVALID_SPAN
from opentelemetry.trace.span import Span as OtelSpan
from opentelemetry.util.types import AttributeValue as OtelAttributeValue

import ddtrace
from ddtrace.internal.constants import SPAN_API_OTEL
from ddtrace.internal.logger import get_logger
from ddtrace.propagation.http import _TraceContext
from ddtrace.trace import Tracer as DDTracer

from .span import Span


log = get_logger(__name__)


OTEL_VERSION = tuple(int(x) for x in version.__version__.split(".")[:3])


class TracerProvider(OtelTracerProvider):
    """
    Entry point of the OpenTelemetry API and provides access to OpenTelemetry compatible Tracers.
    One TracerProvider should be initialized and set per application.
    """

    def __init__(self) -> None:
        self._ddtracer = ddtrace.tracer
        super().__init__()

    if OTEL_VERSION >= (1, 26):
        # OpenTelemetry 1.26+ has a new get_tracer signature
        # https://github.com/open-telemetry/opentelemetry-python/commit/d4e13bdf95190314b0d21a9357f850fa2e6a4cd3
        # The new signature includes an `attributes` parameter which is used by opentelemetry internals.
        def get_tracer(
            self,
            instrumenting_module_name: str,
            instrumenting_library_version: "Optional[str]" = None,
            schema_url: "Optional[str]" = None,
            attributes: "Optional[Dict]" = None,
        ) -> OtelTracer:
            """Returns an opentelemetry compatible Tracer."""
            return Tracer(self._ddtracer)

    else:

        def get_tracer(  # type: ignore[misc]
            self,
            instrumenting_module_name: str,
            instrumenting_library_version: "Optional[str]" = None,
            schema_url: "Optional[str]" = None,
        ) -> OtelTracer:
            """Returns an opentelemetry compatible Tracer."""
            return Tracer(self._ddtracer)


class Tracer(OtelTracer):
    """Starts and/or activates OpenTelemetry compatible Spans using the global Datadog Tracer."""

    def __init__(self, datadog_tracer: "DDTracer") -> None:
        self._tracer = datadog_tracer
        super(Tracer, self).__init__()

    def start_span(
        self,
        name: str,
        context: "Optional[OtelContext]" = None,
        kind: OtelSpanKind = OtelSpanKind.INTERNAL,
        attributes: "Optional[Mapping[str, OtelAttributeValue]]" = None,
        links: "Optional[Sequence[OtelLink]]" = None,
        start_time: "Optional[int]" = None,
        record_exception: bool = True,
        set_status_on_exception: bool = True,
    ) -> OtelSpan:
        """Creates and starts an opentelemetry span."""
        # Get active otel span
        curr_otel_span = get_current_span(context)
        if curr_otel_span is INVALID_SPAN:
            # There is no active datadog/otel span
            dd_active: Optional[Union[ddtrace.trace.Context, ddtrace.trace.Span]] = None
        elif isinstance(curr_otel_span, Span):
            # Get underlying ddtrace span from the active otel span
            dd_active = curr_otel_span._ddspan
        elif isinstance(curr_otel_span, OtelSpan):
            # Otel span was not generated by the ddtrace library and does not have an underlying ddtrace span.
            # Convert otel span to a ddtrace context object.
            trace_id, span_id, _, tf, ts, _ = curr_otel_span.get_span_context()
            trace_state = ts.to_header() if ts else None
            dd_active = _TraceContext._get_context(trace_id, span_id, tf, trace_state)
        else:
            log.error(
                "Programming Error: The current active Span is not supported by ddtrace. The following span will not "
                "have a parent: %s. Please open a github issue at: https://github.com/Datadog/dd-trace-py and avoid "
                "setting the ddtrace OpenTelemetry TracerProvider.",
                curr_otel_span,
            )
        # Create a new Datadog span (not activated), then return a valid OTel span
        dd_span = self._tracer.start_span(name, child_of=dd_active, activate=False, span_api=SPAN_API_OTEL)

        if links:
            for link in links:
                dd_span.set_link(
                    link.context.trace_id,
                    link.context.span_id,
                    link.context.trace_state.to_header(),
                    link.context.trace_flags,
                    link.attributes,
                )
        return Span(
            dd_span,
            kind=kind,
            attributes=attributes,
            start_time=start_time,
            record_exception=record_exception,
            set_status_on_exception=set_status_on_exception,
        )

    @contextmanager
    def start_as_current_span(
        self,
        name: str,
        context: "Optional[OtelContext]" = None,
        kind: OtelSpanKind = OtelSpanKind.INTERNAL,
        attributes: "Optional[Mapping[str, OtelAttributeValue]]" = None,
        links: "Optional[Sequence[OtelLink]]" = None,
        start_time: Optional[int] = None,
        record_exception: bool = True,
        set_status_on_exception: bool = True,
        end_on_exit: bool = True,
    ) -> "Iterator[OtelSpan]":
        """Context manager for creating and activating a new opentelemetry span."""
        # Create a new non-active OTel span wrapper
        span = self.start_span(
            name,
            context=context,
            kind=kind,
            attributes=attributes,
            links=links,
            start_time=start_time,
            record_exception=record_exception,
            set_status_on_exception=set_status_on_exception,
        )

        with use_span(
            span,
            end_on_exit=end_on_exit,
            record_exception=record_exception,
            set_status_on_exception=set_status_on_exception,
        ) as span:
            yield span
