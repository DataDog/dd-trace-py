# CVE-2024-53908 Test Implementation

This document describes the implementation of tests for CVE-2024-53908, a SQL injection vulnerability in Django's HasKey lookup when using Oracle database.

## CVE Details

- **CVE ID**: CVE-2024-53908
- **Description**: Direct use of `django.db.models.fields.json.HasKey` lookup, when using an Oracle database, is subject to SQL injection if untrusted data is used as the `lhs` value.
- **Affected Versions**:
  - Django 5.1 prior to 5.1.4
  - Django 5.0 prior to 5.0.10
  - Django 4.2 prior to 4.2.17
- **Database Specific**: Oracle database only
- **Safe Usage**: Applications using `jsonfield.has_key` lookup via double underscores are not affected

## Implementation

### Files Created/Modified

1. **Oracle Settings**: `tests/appsec/integrations/django_tests/django_app/settings_oracle.py`
   - Django settings configured for Oracle database connection

2. **Vulnerable Model**: `tests/appsec/integrations/django_tests/django_app/models.py`
   - `Item` model with JSONField for testing

3. **Vulnerable Views**: `tests/appsec/integrations/django_tests/django_app/views.py`
   - `cve_insert_test_data()`: Insert test data
   - `cve_clear_database()`: Clear test data
   - `cve_lookup_key_view()`: **Vulnerable view using HasKey lookup**

4. **URL Patterns**: `tests/appsec/integrations/django_tests/django_app/urls.py`
   - Added URL routes for CVE testing endpoints

5. **Test Suite**: `tests/appsec/iast/test_cve_2024_53908.py`
   - Comprehensive tests for the vulnerability

6. **Docker Configuration**: `docker-compose.yml`
   - Added Oracle database container

7. **Environment Matrix**: `hatch.toml`
   - Added Django 5.1.0 testing environment

8. **Django Server Enhancement**: `tests/appsec/appsec_utils.py`
   - Enhanced `django_server()` to support custom settings and migrations

## Vulnerable Code Pattern

The vulnerable code in `cve_lookup_key_view()` demonstrates the issue:

```python
from django.db.models import F
from django.db.models.fields.json import HasKey

# ❌ Vulnerable to SQL Injection in Oracle
lookup = HasKey(F('data'), key)  # key comes from user input
results = Item.objects.filter(lookup)
```

## Safe Alternative

The safe alternative using double underscores:

```python
# ✅ Safe - not affected by CVE-2024-53908
results = Item.objects.filter(data__has_key=key)
```

## Testing

### Run All Tests

```bash
python -m pytest tests/appsec/iast/test_cve_2024_53908.py -v --no-cov
```

### Individual Tests

1. **Documentation Test** (always passes):
   ```bash
   python -m pytest tests/appsec/iast/test_cve_2024_53908.py::TestCVE202453908::test_cve_2024_53908_documentation -v -s
   ```

2. **SQLite Test** (demonstrates safe behavior):
   ```bash
   python -m pytest tests/appsec/iast/test_cve_2024_53908.py::TestCVE202453908::test_cve_2024_53908_safe_with_sqlite -v
   ```

3. **Oracle Test** (requires Oracle container - skipped by default):
   ```bash
   python -m pytest tests/appsec/iast/test_cve_2024_53908.py::TestCVE202453908::test_cve_2024_53908_vulnerability_with_oracle -v
   ```

4. **Curl Examples** (shows manual testing commands):
   ```bash
   python -m pytest tests/appsec/iast/test_cve_2024_53908.py::TestCVE202453908::test_cve_2024_53908_curl_example -v -s
   ```

## Manual Testing with Oracle

### 1. Start Oracle Container

```bash
docker run -d --name oracle-xe -p 1521:1521 -e ORACLE_PASSWORD=oracle gvenzl/oracle-xe:21-slim
```

### 2. Start Django Server with Oracle

```bash
DJANGO_SETTINGS_MODULE=tests.appsec.integrations.django_tests.django_app.settings_oracle \
python tests/appsec/integrations/django_tests/django_app/manage.py migrate

DJANGO_SETTINGS_MODULE=tests.appsec.integrations.django_tests.django_app.settings_oracle \
python tests/appsec/integrations/django_tests/django_app/manage.py runserver 8000
```

### 3. Test Endpoints

```bash
# Insert test data
curl -X GET 'http://localhost:8000/cve/insert-test-data/'

# Test normal functionality
curl -X GET 'http://localhost:8000/cve/lookup-key/?key=secure_key'
curl -X GET 'http://localhost:8000/cve/lookup-key/?key=other_key'

# Test SQL injection payloads
curl -X GET "http://localhost:8000/cve/lookup-key/?key=secure_key' OR '1'='1"
curl -X GET "http://localhost:8000/cve/lookup-key/?key=secure_key' UNION SELECT 1--"
curl -X GET "http://localhost:8000/cve/lookup-key/?key='; DROP TABLE cve_test_item; --"

# Clean up
curl -X GET 'http://localhost:8000/cve/clear-database/'
```

## Expected Behavior

### With SQLite (Safe)
- All injection attempts return `{"count": 0}` safely
- No SQL errors or unexpected behavior

### With Oracle (Vulnerable in affected Django versions)
- Normal queries work correctly
- Injection attempts may:
  - Return unexpected counts (successful injection)
  - Cause database errors revealing SQL structure
  - Allow data extraction or manipulation

### With Oracle (Patched Django versions)
- Injection attempts are properly escaped
- Returns safe results similar to SQLite

## References

- [CVE-2024-53908 Details](https://www.incibe.es/incibe-cert/alerta-temprana/vulnerabilidades/cve-2024-53908)
- [Django Security Releases](https://docs.djangoproject.com/en/dev/releases/security/)
- [Django Announce Group](https://groups.google.com/g/django-announce)
- [OSS Security List](https://www.openwall.com/lists/oss-security/2024/12/04/3)

## Notes

- The Oracle test is skipped by default since it requires an Oracle database container
- The implementation demonstrates the vulnerability pattern but requires Oracle to exploit
- IAST (Interactive Application Security Testing) integration is included for runtime analysis
- The test framework supports both vulnerable and patched Django versions
