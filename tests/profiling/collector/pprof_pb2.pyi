"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Profile is a common stacktrace profile format.

Measurements represented with this format should follow the
following conventions:

- Consumers should treat unset optional fields as if they had been
  set with their default value.

- When possible, measurements should be stored in "unsampled" form
  that is most useful to humans.  There should be enough
  information present to determine the original sampled values.

- On-disk, the serialized proto must be gzip-compressed.

- The profile is represented as a set of samples, where each sample
  references a sequence of locations, and where each location belongs
  to a mapping.
- There is a N->1 relationship from sample.location_id entries to
  locations. For every sample.location_id entry there must be a
  unique Location with that id.
- There is an optional N->1 relationship from locations to
  mappings. For every nonzero Location.mapping_id there must be a
  unique Mapping with that id.
"""

import builtins
import collections.abc
import sys
import typing

import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Profile(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAMPLE_TYPE_FIELD_NUMBER: builtins.int
    SAMPLE_FIELD_NUMBER: builtins.int
    MAPPING_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    FUNCTION_FIELD_NUMBER: builtins.int
    STRING_TABLE_FIELD_NUMBER: builtins.int
    DROP_FRAMES_FIELD_NUMBER: builtins.int
    KEEP_FRAMES_FIELD_NUMBER: builtins.int
    TIME_NANOS_FIELD_NUMBER: builtins.int
    DURATION_NANOS_FIELD_NUMBER: builtins.int
    PERIOD_TYPE_FIELD_NUMBER: builtins.int
    PERIOD_FIELD_NUMBER: builtins.int
    COMMENT_FIELD_NUMBER: builtins.int
    DEFAULT_SAMPLE_TYPE_FIELD_NUMBER: builtins.int
    drop_frames: builtins.int
    """frames with Function.function_name fully matching the following
    regexp will be dropped from the samples, along with their successors.
    Index into string table.
    """
    keep_frames: builtins.int
    """frames with Function.function_name fully matching the following
    regexp will be kept, even if it matches drop_functions.
    Index into string table.
    """
    time_nanos: builtins.int
    """The following fields are informational, do not affect
    interpretation of results.

    Time of collection (UTC) represented as nanoseconds past the epoch.
    """
    duration_nanos: builtins.int
    """Duration of the profile, if a duration makes sense."""
    period: builtins.int
    """The number of events between sampled occurrences."""
    default_sample_type: builtins.int
    """Index into the string table of the type of the preferred sample
    value. If unset, clients should default to the last sample value.
    """
    @property
    def sample_type(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ValueType]:
        """A description of the samples associated with each Sample.value.
        For a cpu profile this might be:
          [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
        For a heap profile, this might be:
          [["allocations","count"], ["space","bytes"]],
        If one of the values represents the number of events represented
        by the sample, by convention it should be at index 0 and use
        sample_type.unit == "count".
        """
    @property
    def sample(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Sample]:
        """The set of samples recorded in this profile."""
    @property
    def mapping(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Mapping]:
        """Mapping from address ranges to the image/binary/library mapped
        into that address range.  mapping[0] will be the main binary.
        """
    @property
    def location(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Location]:
        """Useful program location"""
    @property
    def function(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Function]:
        """Functions referenced by locations"""
    @property
    def string_table(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """A common table for strings referenced by various messages.
        string_table[0] must always be "".
        """
    @property
    def period_type(self) -> Global___ValueType:
        """The kind of events between sampled occurrences.
        e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
        """
    @property
    def comment(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Freeform text associated to the profile.
        Indices into string table.
        """
    def __init__(
        self,
        *,
        sample_type: collections.abc.Iterable[Global___ValueType] | None = ...,
        sample: collections.abc.Iterable[Global___Sample] | None = ...,
        mapping: collections.abc.Iterable[Global___Mapping] | None = ...,
        location: collections.abc.Iterable[Global___Location] | None = ...,
        function: collections.abc.Iterable[Global___Function] | None = ...,
        string_table: collections.abc.Iterable[builtins.str] | None = ...,
        drop_frames: builtins.int = ...,
        keep_frames: builtins.int = ...,
        time_nanos: builtins.int = ...,
        duration_nanos: builtins.int = ...,
        period_type: Global___ValueType | None = ...,
        period: builtins.int = ...,
        comment: collections.abc.Iterable[builtins.int] | None = ...,
        default_sample_type: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["period_type", b"period_type"]) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "comment",
            b"comment",
            "default_sample_type",
            b"default_sample_type",
            "drop_frames",
            b"drop_frames",
            "duration_nanos",
            b"duration_nanos",
            "function",
            b"function",
            "keep_frames",
            b"keep_frames",
            "location",
            b"location",
            "mapping",
            b"mapping",
            "period",
            b"period",
            "period_type",
            b"period_type",
            "sample",
            b"sample",
            "sample_type",
            b"sample_type",
            "string_table",
            b"string_table",
            "time_nanos",
            b"time_nanos",
        ],
    ) -> None: ...

Global___Profile: typing_extensions.TypeAlias = Profile

@typing.final
class ValueType(google.protobuf.message.Message):
    """ValueType describes the semantics and measurement units of a value."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    UNIT_FIELD_NUMBER: builtins.int
    type: builtins.int
    """Index into string table."""
    unit: builtins.int
    """Index into string table."""
    def __init__(
        self,
        *,
        type: builtins.int = ...,  # noqa: A002
        unit: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["type", b"type", "unit", b"unit"]) -> None: ...

Global___ValueType: typing_extensions.TypeAlias = ValueType

@typing.final
class Sample(google.protobuf.message.Message):
    """Each Sample records values encountered in some program
    context. The program context is typically a stack trace, perhaps
    augmented with auxiliary information like the thread-id, some
    indicator of a higher level request being handled etc.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOCATION_ID_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    @property
    def location_id(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The ids recorded here correspond to a Profile.location.id.
        The leaf is at location_id[0].
        """
    @property
    def value(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The type and unit of each value is defined by the corresponding
        entry in Profile.sample_type. All samples must have the same
        number of values, the same as the length of Profile.sample_type.
        When aggregating multiple samples into a single sample, the
        result has a list of values that is the elemntwise sum of the
        lists of the originals.
        """
    @property
    def label(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Label]:
        """label includes additional context for this sample. It can include
        things like a thread id, allocation size, etc
        """
    def __init__(
        self,
        *,
        location_id: collections.abc.Iterable[builtins.int] | None = ...,
        value: collections.abc.Iterable[builtins.int] | None = ...,
        label: collections.abc.Iterable[Global___Label] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["label", b"label", "location_id", b"location_id", "value", b"value"]
    ) -> None: ...

Global___Sample: typing_extensions.TypeAlias = Sample

@typing.final
class Label(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    STR_FIELD_NUMBER: builtins.int
    NUM_FIELD_NUMBER: builtins.int
    NUM_UNIT_FIELD_NUMBER: builtins.int
    key: builtins.int
    """Index into string table"""
    str: builtins.int
    """At most one of the following must be present
    Index into string table
    """
    num: builtins.int
    num_unit: builtins.int
    """Should only be present when num is present.
    Specifies the units of num.
    Use arbitrary string (for example, "requests") as a custom count unit.
    If no unit is specified, consumer may apply heuristic to deduce the unit.
    Consumers may also  interpret units like "bytes" and "kilobytes" as memory
    units and units like "seconds" and "nanoseconds" as time units,
    and apply appropriate unit conversions to these.
    Index into string table
    """
    def __init__(
        self,
        *,
        key: builtins.int = ...,
        str: builtins.int = ...,  # noqa: A002
        num: builtins.int = ...,
        num_unit: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["key", b"key", "num", b"num", "num_unit", b"num_unit", "str", b"str"]
    ) -> None: ...

Global___Label: typing_extensions.TypeAlias = Label

@typing.final
class Mapping(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    MEMORY_START_FIELD_NUMBER: builtins.int
    MEMORY_LIMIT_FIELD_NUMBER: builtins.int
    FILE_OFFSET_FIELD_NUMBER: builtins.int
    FILENAME_FIELD_NUMBER: builtins.int
    BUILD_ID_FIELD_NUMBER: builtins.int
    HAS_FUNCTIONS_FIELD_NUMBER: builtins.int
    HAS_FILENAMES_FIELD_NUMBER: builtins.int
    HAS_LINE_NUMBERS_FIELD_NUMBER: builtins.int
    HAS_INLINE_FRAMES_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique nonzero id for the mapping."""
    memory_start: builtins.int
    """Address at which the binary (or DLL) is loaded into memory."""
    memory_limit: builtins.int
    """The limit of the address range occupied by this mapping."""
    file_offset: builtins.int
    """Offset in the binary that corresponds to the first mapped address."""
    filename: builtins.int
    """The object this entry is loaded from.  This can be a filename on
    disk for the main binary and shared libraries, or virtual
    abstractions like "[vdso]".
    Index into string table
    """
    build_id: builtins.int
    """A string that uniquely identifies a particular program version
    with high probability. E.g., for binaries generated by GNU tools,
    it could be the contents of the .note.gnu.build-id field.
    Index into string table
    """
    has_functions: builtins.bool
    """The following fields indicate the resolution of symbolic info."""
    has_filenames: builtins.bool
    has_line_numbers: builtins.bool
    has_inline_frames: builtins.bool
    def __init__(
        self,
        *,
        id: builtins.int = ...,  # noqa: A002
        memory_start: builtins.int = ...,
        memory_limit: builtins.int = ...,
        file_offset: builtins.int = ...,
        filename: builtins.int = ...,
        build_id: builtins.int = ...,
        has_functions: builtins.bool = ...,
        has_filenames: builtins.bool = ...,
        has_line_numbers: builtins.bool = ...,
        has_inline_frames: builtins.bool = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "build_id",
            b"build_id",
            "file_offset",
            b"file_offset",
            "filename",
            b"filename",
            "has_filenames",
            b"has_filenames",
            "has_functions",
            b"has_functions",
            "has_inline_frames",
            b"has_inline_frames",
            "has_line_numbers",
            b"has_line_numbers",
            "id",
            b"id",
            "memory_limit",
            b"memory_limit",
            "memory_start",
            b"memory_start",
        ],
    ) -> None: ...

Global___Mapping: typing_extensions.TypeAlias = Mapping

@typing.final
class Location(google.protobuf.message.Message):
    """Describes function and line table debug information."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    MAPPING_ID_FIELD_NUMBER: builtins.int
    ADDRESS_FIELD_NUMBER: builtins.int
    LINE_FIELD_NUMBER: builtins.int
    IS_FOLDED_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique nonzero id for the location.  A profile could use
    instruction addresses or any integer sequence as ids.
    """
    mapping_id: builtins.int
    """The id of the corresponding profile.Mapping for this location.
    It can be unset if the mapping is unknown or not applicable for
    this profile type.
    """
    address: builtins.int
    """The instruction address for this location, if available.  It
    should be within [Mapping.memory_start...Mapping.memory_limit]
    for the corresponding mapping. A non-leaf address may be in the
    middle of a call instruction. It is up to display tools to find
    the beginning of the instruction if necessary.
    """
    is_folded: builtins.bool
    """Provides an indication that multiple symbols map to this location's
    address, for example due to identical code folding by the linker. In that
    case the line information above represents one of the multiple
    symbols. This field must be recomputed when the symbolization state of the
    profile changes.
    """
    @property
    def line(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Line]:
        """Multiple line indicates this location has inlined functions,
        where the last entry represents the caller into which the
        preceding entries were inlined.

        E.g., if memcpy() is inlined into printf:
           line[0].function_name == "memcpy"
           line[1].function_name == "printf"
        """
    def __init__(
        self,
        *,
        id: builtins.int = ...,  # noqa: A002
        mapping_id: builtins.int = ...,
        address: builtins.int = ...,
        line: collections.abc.Iterable[Global___Line] | None = ...,
        is_folded: builtins.bool = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "address", b"address", "id", b"id", "is_folded", b"is_folded", "line", b"line", "mapping_id", b"mapping_id"
        ],
    ) -> None: ...

Global___Location: typing_extensions.TypeAlias = Location

@typing.final
class Line(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FUNCTION_ID_FIELD_NUMBER: builtins.int
    LINE_FIELD_NUMBER: builtins.int
    function_id: builtins.int
    """The id of the corresponding profile.Function for this line."""
    line: builtins.int
    """Line number in source code."""
    def __init__(
        self,
        *,
        function_id: builtins.int = ...,
        line: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["function_id", b"function_id", "line", b"line"]) -> None: ...

Global___Line: typing_extensions.TypeAlias = Line

@typing.final
class Function(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SYSTEM_NAME_FIELD_NUMBER: builtins.int
    FILENAME_FIELD_NUMBER: builtins.int
    START_LINE_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique nonzero id for the function."""
    name: builtins.int
    """Name of the function, in human-readable form if available.
    Index into string table
    """
    system_name: builtins.int
    """Name of the function, as identified by the system.
    For instance, it can be a C++ mangled name.
    Index into string table
    """
    filename: builtins.int
    """Source file containing the function.
    Index into string table
    """
    start_line: builtins.int
    """Line number in source file."""
    def __init__(
        self,
        *,
        id: builtins.int = ...,  # noqa: A002
        name: builtins.int = ...,
        system_name: builtins.int = ...,
        filename: builtins.int = ...,
        start_line: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "filename",
            b"filename",
            "id",
            b"id",
            "name",
            b"name",
            "start_line",
            b"start_line",
            "system_name",
            b"system_name",
        ],
    ) -> None: ...

Global___Function: typing_extensions.TypeAlias = Function
